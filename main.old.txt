        camera->setHorizontalFOV(g_ScreenRatio);
        //           R     G     B     A
        glClearColor(1.0f, 1.0f, 1.0f, 1.0f);

        // "Pintamos" todos os pixels do framebuffer com a cor definida acima,
        // e também resetamos todos os pixels do Z-buffer (depth buffer).
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        glUseProgram(myrenderer->gpuProgramID);


		glm::vec4 camera_position_c;
        if (g_ResetCamera) {
            camera_position_c = glm::vec4 (initial_camera_position.x, initial_camera_position.y, initial_camera_position.z, 1.0f);
            camera->setCenterPosition(camera_position_c);
            g_CameraDistance = initial_camera_distance;
            g_CameraPhi = initial_phi;
            g_CameraTheta = initial_theta;
			g_ResetCamera = false;
        }
        // Computamos a posição da câmera utilizando coordenadas esféricas.  As
        // variáveis g_CameraDistance, g_CameraPhi, e g_CameraTheta são
        // controladas pelo mouse do usuário. Veja as funções CursorPosCallback()
        // e ScrollCallback().
        r = g_CameraDistance;
        y = r*sin(g_CameraPhi);
        z = r*cos(g_CameraPhi)*cos(g_CameraTheta);
        x = r*cos(g_CameraPhi)*sin(g_CameraTheta);


		glm::vec4 camera_view_vector;
		if (g_LookAtCamera) {
            camera->setCenterPosition(glm::vec4(x,y,z,1.0f));
			//camera_view_vector = object_position - camera_position_c;
		} else {
			camera->setViewVector(object_position - glm::vec4(x,y,z,1.0f));
            camera_view_vector = object_position - glm::vec4(x,y,z,1.0f);
		}

        glm::vec4 w = -camera->getViewVector();
        glm::vec4 u = crossproduct(camera->getUpVector(),w);
        glm::vec4 v = crossproduct(w, u);
        // Normalizamos os vetores u e w
        w = w / norm(w);
        u = u / norm(u);
        v = v / norm(v);


        float current_time = (float)glfwGetTime();
        float delta_t = current_time - prev_time;
        prev_time = current_time;
        if (!g_LookAtCamera){
            if (tecla_D_pressionada){
                // Movimenta câmera para direita
                camera_position_c += u * speed * delta_t;
                camera->setCenterPosition(camera_position_c);
            }
            if (tecla_S_pressionada){
                // Movimenta câmera para tras
                camera_position_c += (w) * speed * delta_t;
                camera->setCenterPosition(camera_position_c);

            }
            if (tecla_A_pressionada){
                // Movimenta câmera para esquerda
                camera_position_c += (-u) * speed * delta_t;
                camera->setCenterPosition(camera_position_c);
            }
            if (tecla_W_pressionada){
                // Movimenta câmera para frente
                camera_position_c += (-w) * speed * delta_t;
                camera->setCenterPosition(camera_position_c);
            }
            if (tecla_Q_pressionada){
                // Movimenta câmera para cima
                camera_position_c += v * speed * delta_t;
                camera->setCenterPosition(camera_position_c);
            }
            if (tecla_Z_pressionada){
                // Movimenta câmera para baixo
                camera_position_c += -v * speed * delta_t;
                camera->setCenterPosition(camera_position_c);
            }        

        }
        if(tecla_R_pressionada){
            tecla_R_pressionada = false;
        }
        glm::mat4 modelMatrix = glm::mat4(1.0f);
        // Computamos a matriz "View" utilizando os parâmetros da câmera para
        // definir o sistema de coordenadas da câmera.  Veja slides 2-14, 184-190 e 236-242 do documento Aula_08_Sistemas_de_Coordenadas.pdf.
        glm::mat4 view = camera->getViewMatrix();

        // Agora computamos a matriz de Projeção.
        glm::mat4 projection;



        // Projeção Perspectiva.
        float field_of_view = 3.141592 / 3.0f;
        projection = Matrix_Perspective(field_of_view, g_ScreenRatio, camera->nearplane, camera->farplane);



        glm::mat4 model = Matrix_Identity(); // Transformação identidade de modelagem
        
        // Enviamos as matrizes "view" e "projection" para vertex shader
        // efetivamente aplicadas em todos os pontos.
        glUniformMatrix4fv(myrenderer->view_uniform       , 1 , GL_FALSE , glm::value_ptr(view));
        glUniformMatrix4fv(myrenderer->projection_uniform , 1 , GL_FALSE , glm::value_ptr(projection));
        if(options_manager->isModelLoaded()){
            ModelObject model_object = options_manager->getModelObject();
            //printf("%f,%f,%f\n",model_object.materials[0].diffuse_color.x, model_object.materials[0].diffuse_color.y, model_object.materials[0].diffuse_color.z);
            float max_x = model_object.bbox_max.x;
            float max_y = model_object.bbox_max.y;
            float max_z = model_object.bbox_max.z;
            float min_x = model_object.bbox_min.x;
            float min_y = model_object.bbox_min.y;
            float min_z = model_object.bbox_min.z;
            // Center of the object
            float trans_x = (min_x + max_x) / 2;
            float trans_y = (min_y + max_y) / 2;
            float trans_z = (min_z + max_z) / 2;
            //
            float size_x  = (max_x - min_x);
            float size_y  = (max_y - min_y);
            float size_z  = (max_z - min_z);
            float scale = std::max(size_x,std::max(size_y,size_z));
            //center of object is at trans_x, trans_y, trans_z
            //model_object.setCenterPosition(glm::vec4(trans_x,trans_y,trans_z,1));    
            //so if we translate the opposite coordinates, the center will be at 0,0,0
            glm::vec3 objectTranslate = glm::vec3(-trans_x, -trans_y, -trans_z);
            glm::vec3 objectScale = glm::vec3(3.0f / scale, 3.0f / scale, 3.0f / scale);
            modelMatrix = glm::mat4(1.0f);
            modelMatrix = glm::scale(modelMatrix, objectScale);
            modelMatrix = glm::translate(modelMatrix, objectTranslate);
            if(myrenderer->isClosed2GLActive()){
               ;// positions(&model_object,modelViewProj,myrenderer);
            }
            myrenderer->render(model_object,*camera,g_ScreenWidth,g_ScreenHeight);
        }
        options_manager->ApplyProperties(delta_t,modelMatrix,g_ScreenWidth, g_ScreenHeight);


        glfwSwapBuffers(window);
        glfwPollEvents();